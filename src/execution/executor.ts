import type { HLProvider } from "../provider/provider.js";
import type { Logger } from "../logging/logger.js";
import type { ExecutionPlan, SplitAllocation, SplitExecutionPlan } from "../router/types.js";
import type { ExecutionReceipt, SplitExecutionReceipt } from "./types.js";
import type { CollateralManager } from "../collateral/manager.js";
import type { CollateralReceipt } from "../collateral/types.js";
import type { BuilderConfig } from "../config.js";

/** Wire-format builder object for @nktkas/hyperliquid. */
interface WireBuilder {
  b: `0x${string}`;
  f: number; // 0.1bps units
}

export class Executor {
  private logger: Logger;
  private wireBuilder: WireBuilder | null;
  private approvalChecked = false;

  constructor(
    private provider: HLProvider,
    logger: Logger,
    builderConfig: BuilderConfig | null,
  ) {
    this.logger = logger.child({ module: "executor" });

    if (builderConfig) {
      this.wireBuilder = {
        b: builderConfig.address,
        f: builderConfig.feeBps * 10, // bps → 0.1bps
      };
    } else {
      this.wireBuilder = null;
    }
  }

  /**
   * Ensure the user has approved this builder's fee before trading.
   * Called once per session, before the first trade.
   */
  private async ensureBuilderApproval(userAddress: string): Promise<void> {
    if (!this.wireBuilder || this.approvalChecked) return;

    try {
      const currentApproval = await this.provider.maxBuilderFee({
        user: userAddress,
        builder: this.wireBuilder.b,
      });

      if (currentApproval >= this.wireBuilder.f) {
        this.logger.debug(
          { builder: this.wireBuilder.b, approved: currentApproval, required: this.wireBuilder.f },
          "Builder fee already approved",
        );
        this.approvalChecked = true;
        return;
      }

      // Convert wire 0.1bps back to percentage string for approval
      const bps = this.wireBuilder.f / 10;
      const maxFeeRate = `${(bps * 0.01).toFixed(2)}%`;

      this.logger.warn(
        { builder: this.wireBuilder.b, maxFeeRate },
        "Auto-approving builder fee (one-time on-chain action). Set builder: null in config to disable.",
      );

      await this.provider.approveBuilderFee({
        maxFeeRate,
        builder: this.wireBuilder.b,
      });

      this.approvalChecked = true;
      this.logger.info("Builder fee approved successfully");
    } catch (error) {
      this.logger.warn(
        { error },
        "Failed to check/approve builder fee — will retry on next order. Orders may fail if not pre-approved.",
      );
      // Do NOT set approvalChecked = true so we retry on the next order attempt
    }
  }

  /**
   * Execute a plan generated by the router.
   * This is the ONLY place orders are placed.
   */
  async execute(plan: ExecutionPlan, userAddress: string): Promise<ExecutionReceipt> {
    await this.ensureBuilderApproval(userAddress);

    this.logger.info(
      {
        market: plan.market.coin,
        side: plan.side,
        size: plan.size,
        price: plan.price,
      },
      "Executing order",
    );

    try {
      await this.applyLeverageIfRequested(plan);

      const result = await this.provider.placeOrder(
        {
          assetIndex: plan.market.assetIndex,
          isBuy: plan.side === "buy",
          price: plan.price,
          size: plan.size,
          reduceOnly: false,
          orderType: plan.orderType,
        },
        this.wireBuilder ?? undefined,
      );

      // Parse the order result to extract fill info
      const status = result.statuses[0];
      let orderId: number | undefined;
      let filledSize = "0";
      let avgPrice = "0";

      if (status && typeof status === "object") {
        if ("filled" in status) {
          orderId = status.filled.oid;
          filledSize = status.filled.totalSz;
          avgPrice = status.filled.avgPx;
        } else if ("resting" in status) {
          orderId = status.resting.oid;
          // Resting means not yet filled — IOC orders shouldn't reach here
          filledSize = "0";
          avgPrice = plan.price;
        } else if ("error" in status) {
          this.logger.error({ error: status.error, plan }, "Order rejected");
          return {
            success: false,
            market: plan.market,
            side: plan.side,
            requestedSize: plan.size,
            filledSize: "0",
            avgPrice: "0",
            orderId: undefined,
            timestamp: Date.now(),
            error: status.error,
            raw: result,
          };
        }
      }

      const receipt: ExecutionReceipt = {
        success: true,
        market: plan.market,
        side: plan.side,
        requestedSize: plan.size,
        filledSize,
        avgPrice,
        orderId,
        timestamp: Date.now(),
        raw: result,
      };

      this.logger.info(
        {
          orderId: receipt.orderId,
          filledSize: receipt.filledSize,
          avgPrice: receipt.avgPrice,
        },
        "Order executed",
      );

      return receipt;
    } catch (error) {
      this.logger.error({ error, plan }, "Order execution failed");

      return {
        success: false,
        market: plan.market,
        side: plan.side,
        requestedSize: plan.size,
        filledSize: "0",
        avgPrice: "0",
        orderId: undefined,
        timestamp: Date.now(),
        error: error instanceof Error ? error.message : String(error),
        raw: error,
      };
    }
  }

  /**
   * Execute a split order plan across multiple markets.
   * Flow: prepare collateral → batch place all leg orders → aggregate receipts.
   */
  async executeSplit(
    plan: SplitExecutionPlan,
    collateralManager: CollateralManager,
    userAddress: string,
  ): Promise<SplitExecutionReceipt> {
    await this.ensureBuilderApproval(userAddress);

    this.logger.info(
      {
        legs: plan.legs.length,
        side: plan.side,
        totalSize: plan.totalSize,
        markets: plan.legs.map((l) => l.market.coin),
      },
      "Executing split order",
    );

    const timestamp = Date.now();

    // Step 1: Apply requested leverage per leg/market before any transfers/orders.
    try {
      await this.applySplitLeverage(plan);
    } catch (error) {
      const collateralReceipt: CollateralReceipt = {
        success: false,
        swapsExecuted: [],
        abstractionWasEnabled: false,
        error: error instanceof Error ? error.message : String(error),
      };
      return {
        success: false,
        legs: [],
        collateralReceipt,
        totalRequestedSize: plan.totalSize,
        totalFilledSize: "0",
        aggregateAvgPrice: "0",
        timestamp,
        error: `Leverage setup failed: ${collateralReceipt.error}`,
      };
    }

    // Step 2: Estimate collateral using live balances at execution time.
    const allocations: SplitAllocation[] = this.buildAllocationsFromLegs(plan);
    const collateralPlan = await collateralManager.estimateRequirements(
      allocations,
      userAddress,
    );

    // Step 3: Prepare collateral (enable abstraction, swap if needed)
    let collateralReceipt: CollateralReceipt;
    if (collateralPlan.swapsNeeded) {
      collateralReceipt = await collateralManager.prepare(
        collateralPlan,
        userAddress,
      );
      if (!collateralReceipt.success) {
        return {
          success: false,
          legs: [],
          collateralReceipt,
          totalRequestedSize: plan.totalSize,
          totalFilledSize: "0",
          aggregateAvgPrice: "0",
          timestamp,
          error: `Collateral preparation failed: ${collateralReceipt.error}`,
        };
      }
    } else {
      collateralReceipt = {
        success: true,
        swapsExecuted: [],
        abstractionWasEnabled: false,
      };
    }

    // Step 4: Place all leg orders via batchOrders (single atomic API call)
    try {
      const orderParams = plan.legs.map((leg) => ({
        assetIndex: leg.market.assetIndex,
        isBuy: leg.side === "buy",
        price: leg.price,
        size: leg.size,
        reduceOnly: false,
        orderType: leg.orderType,
      }));

      const result = await this.provider.batchOrders(
        orderParams,
        this.wireBuilder ?? undefined,
      );

      // Step 5: Map each status to a per-leg receipt
      const legs: ExecutionReceipt[] = plan.legs.map((leg, i) => {
        const status = result.statuses[i];
        let orderId: number | undefined;
        let filledSize = "0";
        let avgPrice = "0";
        let success = false;
        let error: string | undefined;

        if (status && typeof status === "object") {
          if ("filled" in status) {
            orderId = status.filled.oid;
            filledSize = status.filled.totalSz;
            avgPrice = status.filled.avgPx;
            success = true;
          } else if ("resting" in status) {
            orderId = status.resting.oid;
            filledSize = "0";
            avgPrice = leg.price;
            success = true; // Order is resting, not failed
          } else if ("error" in status) {
            error = status.error;
          }
        }

        return {
          success,
          market: leg.market,
          side: leg.side,
          requestedSize: leg.size,
          filledSize,
          avgPrice,
          orderId,
          timestamp,
          error,
          raw: status,
        };
      });

      // Step 6: Aggregate results
      let totalFilledSize = 0;
      let totalFilledCost = 0;
      let allSuccess = true;

      for (const leg of legs) {
        const filled = parseFloat(leg.filledSize);
        const price = parseFloat(leg.avgPrice);
        totalFilledSize += filled;
        totalFilledCost += filled * price;
        if (!leg.success) allSuccess = false;
      }

      const aggregateAvgPrice = totalFilledSize > 0
        ? (totalFilledCost / totalFilledSize).toFixed(6)
        : "0";

      this.logger.info(
        {
          allSuccess,
          totalFilledSize,
          aggregateAvgPrice,
          legsSucceeded: legs.filter((l) => l.success).length,
          legsFailed: legs.filter((l) => !l.success).length,
        },
        "Split order executed",
      );

      return {
        success: allSuccess,
        legs,
        collateralReceipt,
        totalRequestedSize: plan.totalSize,
        totalFilledSize: totalFilledSize.toString(),
        aggregateAvgPrice,
        timestamp,
      };
    } catch (error) {
      this.logger.error({ error }, "Split order execution failed");
      return {
        success: false,
        legs: [],
        collateralReceipt,
        totalRequestedSize: plan.totalSize,
        totalFilledSize: "0",
        aggregateAvgPrice: "0",
        timestamp,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  private buildAllocationsFromLegs(plan: SplitExecutionPlan): SplitAllocation[] {
    const totalSize = plan.legs.reduce((sum, leg) => sum + parseFloat(leg.size), 0);
    return plan.legs.map((leg) => {
      const size = parseFloat(leg.size);
      const estimatedAvgPrice = parseFloat(leg.price);
      const estimatedCost = size * estimatedAvgPrice;
      return {
        market: leg.market,
        size,
        estimatedCost,
        estimatedAvgPrice,
        proportion: totalSize > 0 ? size / totalSize : 0,
      };
    });
  }

  private async applyLeverageIfRequested(plan: ExecutionPlan): Promise<void> {
    if (plan.leverage === undefined) return;
    if (!Number.isFinite(plan.leverage) || plan.leverage <= 0) {
      throw new Error(`Invalid leverage "${plan.leverage}" for ${plan.market.coin}`);
    }
    const isCross = plan.isCross ?? true;
    this.logger.info(
      { market: plan.market.coin, leverage: plan.leverage, isCross },
      "Applying leverage before execution",
    );
    await this.provider.setLeverage(plan.market.coin, plan.leverage, isCross);
  }

  private async applySplitLeverage(plan: SplitExecutionPlan): Promise<void> {
    const applied = new Set<string>();
    for (const leg of plan.legs) {
      if (leg.leverage === undefined) continue;
      const key = `${leg.market.coin}:${leg.leverage}:${leg.isCross ?? true}`;
      if (applied.has(key)) continue;
      await this.applyLeverageIfRequested(leg);
      applied.add(key);
    }
  }
}
