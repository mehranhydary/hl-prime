import type { HLProvider } from "../provider/provider.js";
import type { Logger } from "../logging/logger.js";
import type { ExecutionPlan, SplitExecutionPlan } from "../router/types.js";
import type { ExecutionReceipt, SplitExecutionReceipt } from "./types.js";
import type { CollateralManager } from "../collateral/manager.js";
import type { CollateralReceipt } from "../collateral/types.js";

export class Executor {
  private logger: Logger;

  constructor(
    private provider: HLProvider,
    logger: Logger,
  ) {
    this.logger = logger.child({ module: "executor" });
  }

  /**
   * Execute a plan generated by the router.
   * This is the ONLY place orders are placed.
   */
  async execute(plan: ExecutionPlan): Promise<ExecutionReceipt> {
    this.logger.info(
      {
        market: plan.market.coin,
        side: plan.side,
        size: plan.size,
        price: plan.price,
      },
      "Executing order",
    );

    try {
      const result = await this.provider.placeOrder({
        assetIndex: plan.market.assetIndex,
        isBuy: plan.side === "buy",
        price: plan.price,
        size: plan.size,
        reduceOnly: false,
        orderType: plan.orderType,
      });

      // Parse the order result to extract fill info
      const status = result.statuses[0];
      let orderId: number | undefined;
      let filledSize = "0";
      let avgPrice = "0";

      if (status && typeof status === "object") {
        if ("filled" in status) {
          orderId = status.filled.oid;
          filledSize = status.filled.totalSz;
          avgPrice = status.filled.avgPx;
        } else if ("resting" in status) {
          orderId = status.resting.oid;
          // Resting means not yet filled — IOC orders shouldn't reach here
          filledSize = "0";
          avgPrice = plan.price;
        } else if ("error" in status) {
          this.logger.error({ error: status.error, plan }, "Order rejected");
          return {
            success: false,
            market: plan.market,
            side: plan.side,
            requestedSize: plan.size,
            filledSize: "0",
            avgPrice: "0",
            orderId: undefined,
            timestamp: Date.now(),
            error: status.error,
            raw: result,
          };
        }
      }

      const receipt: ExecutionReceipt = {
        success: true,
        market: plan.market,
        side: plan.side,
        requestedSize: plan.size,
        filledSize,
        avgPrice,
        orderId,
        timestamp: Date.now(),
        raw: result,
      };

      this.logger.info(
        {
          orderId: receipt.orderId,
          filledSize: receipt.filledSize,
          avgPrice: receipt.avgPrice,
        },
        "Order executed",
      );

      return receipt;
    } catch (error) {
      this.logger.error({ error, plan }, "Order execution failed");

      return {
        success: false,
        market: plan.market,
        side: plan.side,
        requestedSize: plan.size,
        filledSize: "0",
        avgPrice: "0",
        orderId: undefined,
        timestamp: Date.now(),
        error: error instanceof Error ? error.message : String(error),
        raw: error,
      };
    }
  }

  /**
   * Execute a split order plan across multiple markets.
   * Flow: prepare collateral → batch place all leg orders → aggregate receipts.
   */
  async executeSplit(
    plan: SplitExecutionPlan,
    collateralManager: CollateralManager,
    userAddress: string,
  ): Promise<SplitExecutionReceipt> {
    this.logger.info(
      {
        legs: plan.legs.length,
        side: plan.side,
        totalSize: plan.totalSize,
        markets: plan.legs.map((l) => l.market.coin),
      },
      "Executing split order",
    );

    const timestamp = Date.now();

    // Step 1: Prepare collateral (enable abstraction, swap if needed)
    let collateralReceipt: CollateralReceipt;
    if (plan.collateralPlan.swapsNeeded) {
      collateralReceipt = await collateralManager.prepare(
        plan.collateralPlan,
        userAddress,
      );
      if (!collateralReceipt.success) {
        return {
          success: false,
          legs: [],
          collateralReceipt,
          totalRequestedSize: plan.totalSize,
          totalFilledSize: "0",
          aggregateAvgPrice: "0",
          timestamp,
          error: `Collateral preparation failed: ${collateralReceipt.error}`,
        };
      }
    } else {
      collateralReceipt = {
        success: true,
        swapsExecuted: [],
        abstractionWasEnabled: false,
      };
    }

    // Step 2: Place all leg orders via batchOrders (single atomic API call)
    try {
      const orderParams = plan.legs.map((leg) => ({
        assetIndex: leg.market.assetIndex,
        isBuy: leg.side === "buy",
        price: leg.price,
        size: leg.size,
        reduceOnly: false,
        orderType: leg.orderType,
      }));

      const result = await this.provider.batchOrders(orderParams);

      // Step 3: Map each status to a per-leg receipt
      const legs: ExecutionReceipt[] = plan.legs.map((leg, i) => {
        const status = result.statuses[i];
        let orderId: number | undefined;
        let filledSize = "0";
        let avgPrice = "0";
        let success = false;
        let error: string | undefined;

        if (status && typeof status === "object") {
          if ("filled" in status) {
            orderId = status.filled.oid;
            filledSize = status.filled.totalSz;
            avgPrice = status.filled.avgPx;
            success = true;
          } else if ("resting" in status) {
            orderId = status.resting.oid;
            filledSize = "0";
            avgPrice = leg.price;
            success = true; // Order is resting, not failed
          } else if ("error" in status) {
            error = status.error;
          }
        }

        return {
          success,
          market: leg.market,
          side: leg.side,
          requestedSize: leg.size,
          filledSize,
          avgPrice,
          orderId,
          timestamp,
          error,
          raw: status,
        };
      });

      // Step 4: Aggregate results
      let totalFilledSize = 0;
      let totalFilledCost = 0;
      let allSuccess = true;

      for (const leg of legs) {
        const filled = parseFloat(leg.filledSize);
        const price = parseFloat(leg.avgPrice);
        totalFilledSize += filled;
        totalFilledCost += filled * price;
        if (!leg.success) allSuccess = false;
      }

      const aggregateAvgPrice = totalFilledSize > 0
        ? (totalFilledCost / totalFilledSize).toFixed(6)
        : "0";

      this.logger.info(
        {
          allSuccess,
          totalFilledSize,
          aggregateAvgPrice,
          legsSucceeded: legs.filter((l) => l.success).length,
          legsFailed: legs.filter((l) => !l.success).length,
        },
        "Split order executed",
      );

      return {
        success: allSuccess,
        legs,
        collateralReceipt,
        totalRequestedSize: plan.totalSize,
        totalFilledSize: totalFilledSize.toString(),
        aggregateAvgPrice,
        timestamp,
      };
    } catch (error) {
      this.logger.error({ error }, "Split order execution failed");
      return {
        success: false,
        legs: [],
        collateralReceipt,
        totalRequestedSize: plan.totalSize,
        totalFilledSize: "0",
        aggregateAvgPrice: "0",
        timestamp,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}
