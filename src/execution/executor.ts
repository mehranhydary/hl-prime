import type { HLProvider } from "../provider/provider.js";
import type { Logger } from "../logging/logger.js";
import type { ExecutionPlan } from "../router/types.js";
import type { ExecutionReceipt } from "./types.js";

export class Executor {
  private logger: Logger;

  constructor(
    private provider: HLProvider,
    logger: Logger,
  ) {
    this.logger = logger.child({ module: "executor" });
  }

  /**
   * Execute a plan generated by the router.
   * This is the ONLY place orders are placed.
   */
  async execute(plan: ExecutionPlan): Promise<ExecutionReceipt> {
    this.logger.info(
      {
        market: plan.market.coin,
        side: plan.side,
        size: plan.size,
        price: plan.price,
      },
      "Executing order",
    );

    try {
      const result = await this.provider.placeOrder({
        assetIndex: plan.market.assetIndex,
        isBuy: plan.side === "buy",
        price: plan.price,
        size: plan.size,
        reduceOnly: false,
        orderType: plan.orderType,
      });

      // Parse the order result to extract fill info
      const status = result.statuses[0];
      let orderId: number | undefined;
      let filledSize = "0";
      let avgPrice = "0";

      if (status && typeof status === "object") {
        if ("filled" in status) {
          orderId = status.filled.oid;
          filledSize = status.filled.totalSz;
          avgPrice = status.filled.avgPx;
        } else if ("resting" in status) {
          orderId = status.resting.oid;
          // Resting means not yet filled â€” IOC orders shouldn't reach here
          filledSize = "0";
          avgPrice = plan.price;
        } else if ("error" in status) {
          this.logger.error({ error: status.error, plan }, "Order rejected");
          return {
            success: false,
            market: plan.market,
            side: plan.side,
            requestedSize: plan.size,
            filledSize: "0",
            avgPrice: "0",
            orderId: undefined,
            timestamp: Date.now(),
            error: status.error,
            raw: result,
          };
        }
      }

      const receipt: ExecutionReceipt = {
        success: true,
        market: plan.market,
        side: plan.side,
        requestedSize: plan.size,
        filledSize,
        avgPrice,
        orderId,
        timestamp: Date.now(),
        raw: result,
      };

      this.logger.info(
        {
          orderId: receipt.orderId,
          filledSize: receipt.filledSize,
          avgPrice: receipt.avgPrice,
        },
        "Order executed",
      );

      return receipt;
    } catch (error) {
      this.logger.error({ error, plan }, "Order execution failed");

      return {
        success: false,
        market: plan.market,
        side: plan.side,
        requestedSize: plan.size,
        filledSize: "0",
        avgPrice: "0",
        orderId: undefined,
        timestamp: Date.now(),
        error: error instanceof Error ? error.message : String(error),
        raw: error,
      };
    }
  }
}
